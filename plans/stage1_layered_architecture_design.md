# Проектирование слоистой архитектуры приложения - Этап 1

## 1. Общая концепция слоистой архитектуры

Архитектура приложения будет построена по принципу разделения ответственностей на три основных уровня:

```
┌─────────────────┐
│      UI         │ ← Компоненты и экраны
├─────────────────┤
│ Business Logic  │ ← Сервисы, вычисления
├─────────────────┤
│     Data        │ ← Хранилище данных, модели
└─────────────────┘
```

Каждый слой имеет четко определенные обязанности и взаимодействует с другими слоями через строго определенные интерфейсы.

## 2. UI уровень (Presentation Layer)

### 2.1. Назначение
- Отображение информации пользователю
- Обработка пользовательского ввода
- Визуализация интерфейса

### 2.2. Компоненты
- Экраны (Screens): CalendarScreen, StatisticsScreen, SettingsScreen и др.
- Компоненты пользовательского интерфейса: CalendarComponent, CycleDayMarker, StatisticsChart и др.
- Навигационные компоненты: StackNavigator, TabNavigator

### 2.3. Зависимости
- Использует хуки из BLL уровня для получения данных
- Использует компоненты из react-native, react-native-calendars
- Использует стили из nativewind

### 2.4. Правила взаимодействия
- Не содержит бизнес-логики
- Получает данные только через хуки из BLL уровня
- Передает действия пользователя в BLL уровень через вызовы методов

## 3. Business Logic уровень (Business Logic Layer)

### 3.1. Назначение
- Обработка бизнес-правил
- Выполнение вычислений и анализа
- Координация между различными компонентами

### 3.2. Компоненты
- Сервисы: CycleTrackingService, NotificationService, StatisticsService, ExportService
- Кастомные хуки: useCycleTracking, useNotifications, useTheme, useStatistics
- Управление состоянием: MobX stores

### 3.3. Зависимости
- Использует компоненты DAL уровня для доступа к данным
- Использует react-native-push-notification для уведомлений
- Использует вспомогательные функции из utils уровня

### 3.4. Правила взаимодействия
- Не содержит кода представления
- Не содержит прямого доступа к UI компонентам
- Взаимодействует с DAL уровнем через интерфейсы репозиториев

## 4. Data уровень (Data Access Layer)

### 4.1. Назначение
- Хранение и извлечение данных
- Управление локальной базой данных
- Обеспечение целостности данных

### 4.2. Компоненты
- Модели данных: CycleRecordModel, CycleStatsModel, SettingsModel
- Репозитории: CycleRepository, SettingsRepository
- Абстрактные интерфейсы: IDataRepository, ISettingsStorage

### 4.3. Зависимости
- Использует react-native-sqlite-storage для хранения основных данных
- Использует @react-native-async-storage/async-storage для хранения настроек
- Использует валидацию из вспомогательных библиотек

### 4.4. Правила взаимодействия
- Не содержит бизнес-логики
- Предоставляет чистые интерфейсы для работы с данными
- Обеспечивает безопасность и целостность хранимых данных

## 5. Архитектурные ограничения и принципы

### 5.1. Принцип Dependency Inversion
- Высокоуровневые модули не зависят от низкоуровневых модулей
- Абстракции не зависят от деталей, а детали зависят от абстракций

### 5.2. Принцип единственной ответственности
- Каждый компонент имеет одну и только одну причину для изменения
- Разделение обязанностей между слоями

### 5.3. Принцип открытости/закрытости
- Компоненты открыты для расширения, но закрыты для модификации
- Использование интерфейсов для обеспечения гибкости

### 5.4. Принцип инверсии зависимостей
- Зависимости направлены от конкретных реализаций к абстракциям
- Использование внедрения зависимостей для управления связями

## 6. Потоки данных в архитектуре

### 6.1. Чтение данных
UI → Hook → Service → Repository → Database

### 6.2. Запись данных
UI → Hook → Service → Repository → Database

### 6.3. Обработка событий
UI → Hook → Service → (вычисления/уведомления) → Repository → Database

## 7. Обработка ошибок в слоях

### 7.1. UI уровень
- Обработка ошибок от BLL уровня
- Отображение пользовательских сообщений об ошибках
- Обеспечение отказоустойчивости интерфейса

### 7.2. BLL уровень
- Валидация входных данных
- Обработка ошибок от DAL уровня
- Логирование ошибок

### 7.3. DAL уровень
- Валидация данных перед сохранением
- Обработка ошибок базы данных
- Обеспечение целостности данных